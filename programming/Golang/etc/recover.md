# 복구(recover)
> go에서는 패닉에 걸리면 프로그램이 죽어버리는데 이를 살려주기 위해 recover를 사용함💫

## 1. 패닉(panic)
+ **런타임 중 발생하는 치명적인 에러**를 뜻함   

   >ex) 배열에서 할당되지않은 인덱스에 접근할 때 발생하는 경우 
+ 프로그램이 더 이상 실행될 수 없는 수준의 에러로, 패닉이 발생하면 프로그램이 중도 종료되어버림
   + 일반적인 에러는 발생하더라도 프로그램이 종료되지 않음   
   + 패닉이 발생한 시점에서 프로그램이 즉시 멈추기 때문에, 그 이후에 있는 구문은 실행되지 않음
   + 패닉이 발생하면 실행중인 고루틴을 멈추나, **defer를 통해 예약해둔 함수는 호출이 보장**됨
+ 개발자가 패닉이 필요하다고 느끼는 부분에 대해 go 빌트인 함수 ```panic()```함수를 사용해서 패닉처리 가능함


## 2. recover() 함수
+ 패닉이 발생해도 ```recover()```함수를 통해 프로그램이 종료되는 것을 막고 복구이 시킬 수 있음
   + 프로그램이 종료되기 전, defer() 함수를 통해 예약해두면 패닉이 발생해도 회복시켜줌
   + recover() 함수는 에러 메시지를 반환해주므로, 어느부분에 대해 패닉이 걸렸는데 에러메시지를 출력해서 확인 가능함
   
      ```   
      func main() {
         arr:= []int{} //배열 arr 선언
         defer func() {
           r:=recover() //panic발생시 복구처리
            fmt.Println(recover()) //패닉이 발생하지 않으면 리턴값은 nil, 발생한 경우 에러메시지 전달해줌
         }()
      
         x:=arr[4] //배열 arr의 할당되지 않은 인덱스에 대해 값 호출
      }
      ```  
      
      
      
## 3. defer() 함수
+ defer를 통해 특정 구문을 함수 내 마지막에서 실행 가능함
+ defer를 사용하면 list 에 함수 호출을 기록해서, 주변함수가 리턴된 이후에 실행됨
+ defer 구문을 사용할 때의 3가지 규칙
   + defer에 넣는 함수 인자는 **defer가 사용될 때를 기준으로 평가함**
      ```
      func main() {
         i:=10
         defer fmt.Println(i) //i=0일 때 호출되었으므로, 사용될 때를 기준으로 i를 평가해버림
         i--
         return
      }
      ```
   + defer로 넣는 함수 호출은 **LIFO(Last-Input First-Output)** , 즉 스택에 들어가 실행됨
      ```
      func main() {
         for i:=0; i<10; i++ {
            defer fmt.Print(i)//스택의 성질 때문에, 출력은 "9876543210"
         }
      }
      ```
   + defer로 넣은 함수들은 반환하는 **함수의 named return value를 읽고 할당 가능함**
      ```
      func UpValue() (i int) {
         defer func() {
            i++ // UpValue 함수의 리턴 값 i를 증가시킴
         }() // 따라서 1을 리턴을 먼저하고, 그다음 defer에서 수행된 2를 리턴함
         
         return 1
      }
      ```
